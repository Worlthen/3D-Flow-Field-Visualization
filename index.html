<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D体积渲染效果 - 不同色彩方案</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/v4-shims.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#1e40af',
                        secondary: '#7c3aed',
                        accent: '#ec4899',
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                },
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .glow {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            }
            .animate-float {
                animation: float 6s ease-in-out infinite;
            }
            @keyframes float {
                0%, 100% { transform: translateY(0px); }
                50% { transform: translateY(-20px); }
            }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 min-h-screen font-inter text-white">
    <!-- 顶部导航 -->
    <nav class="bg-black/30 backdrop-blur-lg border-b border-white/10 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-cube text-primary text-2xl"></i>
                    <span
                        class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">3D
                        Volume Renderer</span>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="colorModeBtn"
                        class="px-4 py-2 bg-primary/20 hover:bg-primary/30 rounded-lg transition-all duration-300">
                        <i class="fas fa-palette mr-2"></i>
                        <span>色彩模式</span>
                    </button>
                    <button id="resetBtn"
                        class="px-4 py-2 bg-red-500/20 hover:bg-red-500/30 rounded-lg transition-all duration-300">
                        <i class="fas fa-redo mr-2"></i>
                        <span>重置</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主内容区 -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- 标题区域 -->
        <div class="text-center mb-8">
            <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold mb-4">
                <span class="bg-gradient-to-r from-blue-400 via-purple-500 to-pink-500 bg-clip-text text-transparent">
                    3D 体积渲染效果
                </span>
            </h1>
            <p class="text-gray-300 text-lg max-w-3xl mx-auto">
                交互式3D体积渲染演示，使用不同的色彩方案创建梦幻般的视觉效果。点击并拖动鼠标可以旋转视角。
            </p>
        </div>

        <!-- 渲染区域 -->
        <div class="relative rounded-2xl overflow-hidden bg-black/40 border border-white/10 mb-8 glow">
            <canvas id="renderCanvas" class="w-full h-[600px]"></canvas>

            <!-- 加载指示器 -->
            <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center bg-black/70 z-20">
                <div class="text-center">
                    <div
                        class="inline-block animate-spin rounded-full h-16 w-16 border-4 border-primary border-t-transparent mb-4">
                    </div>
                    <p class="text-white text-lg">加载中...</p>
                </div>
            </div>
        </div>

        <!-- 控制面板 -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <!-- 色彩控制 -->
            <div class="bg-black/30 border border-white/10 rounded-xl p-6 backdrop-blur-sm">
                <h3 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fas fa-sliders-h text-primary mr-2"></i>
                    渲染参数
                </h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">密度强度</label>
                        <input type="range" id="densitySlider" min="0.1" max="2.0" step="0.1" value="1.0"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>低</span>
                            <span>高</span>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">步进长度</label>
                        <input type="range" id="stepSlider" min="0.5" max="3.0" step="0.1" value="1.9"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>小</span>
                            <span>大</span>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">最大深度</label>
                        <input type="range" id="depthSlider" min="30" max="150" step="5" value="70"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>浅</span>
                            <span>深</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 色彩方案 -->
            <div class="bg-black/30 border border-white/10 rounded-xl p-6 backdrop-blur-sm">
                <h3 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fas fa-palette text-primary mr-2"></i>
                    色彩方案
                </h3>
                <div class="grid grid-cols-2 gap-3">
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-blue-500 to-purple-600 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[0.01,0.1,1.0]">
                        <span class="block text-xs text-white">蓝色系</span>
                    </button>
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-pink-500 to-red-600 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[1.0,0.1,0.3]">
                        <span class="block text-xs text-white">粉色系</span>
                    </button>
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-green-500 to-teal-600 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[0.1,1.0,0.5]">
                        <span class="block text-xs text-white">绿色系</span>
                    </button>
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-yellow-500 to-orange-600 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[1.0,0.8,0.1]">
                        <span class="block text-xs text-white">黄色系</span>
                    </button>
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-purple-500 to-pink-600 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[0.8,0.1,1.0]">
                        <span class="block text-xs text-white">紫色系</span>
                    </button>
                    <button
                        class="colorSchemeBtn bg-gradient-to-br from-gray-300 to-gray-700 p-3 rounded-lg transition-all duration-300 hover:scale-105"
                        data-colors="[0.8,0.8,0.8]">
                        <span class="block text-xs text-white">黑白系</span>
                    </button>
                </div>
            </div>

            <!-- 信息面板 -->
            <div class="bg-black/30 border border-white/10 rounded-xl p-6 backdrop-blur-sm">
                <h3 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fas fa-info-circle text-primary mr-2"></i>
                    技术信息
                </h3>
                <div class="space-y-3 text-sm text-gray-300">
                    <div class="flex justify-between">
                        <span>渲染模式:</span>
                        <span id="renderMode" class="text-primary font-medium">体积渲染</span>
                    </div>
                    <div class="flex justify-between">
                        <span>帧率:</span>
                        <span id="fpsCounter" class="text-primary font-medium">0 FPS</span>
                    </div>
                    <div class="flex justify-between">
                        <span>分辨率:</span>
                        <span id="resolution" class="text-primary font-medium">0x0</span>
                    </div>
                    <div class="flex justify-between">
                        <span>色彩方案:</span>
                        <span id="colorScheme" class="text-primary font-medium">蓝色系</span>
                    </div>
                </div>
                <div class="mt-4 pt-4 border-t border-white/10">
                    <p class="text-xs text-gray-400">
                        基于WebGL的3D体积渲染技术，使用光线步进算法和Perlin噪声生成复杂的3D效果。
                    </p>
                </div>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="bg-black/40 border-t border-white/10 py-6">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center text-gray-400 text-sm">
            <p>© 2025 3D Volume Renderer | 使用WebGL和光线步进算法创建</p>
            <div class="mt-2 flex justify-center space-x-4">
                <a href="#" class="hover:text-primary transition-colors duration-300">
                    <i class="fas fa-code"></i>
                </a>
                <a href="#" class="hover:text-primary transition-colors duration-300">
                    <i class="fas fa-github"></i>
                </a>
                <a href="#" class="hover:text-primary transition-colors duration-300">
                    <i class="fas fa-info-circle"></i>
                </a>
            </div>
        </div>
    </footer>

    <script>
        // 全局变量
        let canvas, gl;
        let program;
        let time = 0;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let rotationX = 0, rotationY = 0;
        let lastX = 0, lastY = 0;

        // 渲染参数
        let renderParams = {
            densityStrength: 1.0,
            stepLength: 1.9,
            maxDepth: 70.0,
            color: [0.01, 0.1, 1.0],
            colorScheme: "蓝色系"
        };

        // FPS计数器
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;

        // 初始化WebGL
        function initWebGL() {
            canvas = document.getElementById('renderCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                alert('无法初始化WebGL，您的浏览器可能不支持。');
                return;
            }

            // 设置画布大小
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 创建着色器程序
            createShaderProgram();

            // 设置事件监听
            setupEventListeners();

            // 隐藏加载指示器
            setTimeout(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
            }, 1000);

            // 开始渲染
            requestAnimationFrame(render);
        }

        // 调整画布大小
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            // 更新分辨率显示
            document.getElementById('resolution').textContent = `${canvas.width}x${canvas.height}`;
        }

        // 创建着色器程序
        function createShaderProgram() {
            // 顶点着色器
            const vertexShaderSource = `
                attribute vec2 position;
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            // 片段着色器
            const fragmentShaderSource = `
                precision highp float;
                
                uniform vec2 resolution;
                uniform float time;
                uniform vec2 mouse;
                uniform float densityStrength;
                uniform float stepLength;
                uniform float maxDepth;
                uniform vec3 color;
                
                // 噪声函数
                float hash3d(vec3 uv) {
                    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;
                    return fract(cos(f * 3.333) * 100003.9);
                }
                
                float mixP(float f0, float f1, float a) {
                    return mix(f0, f1, a * a * (3.0 - 2.0 * a));
                }
                
                const vec2 zeroOne = vec2(0.0, 1.0);
                
                float noise(vec3 uv) {
                    vec3 fr = fract(uv.xyz);
                    vec3 fl = floor(uv.xyz);
                    
                    float h000 = hash3d(fl);
                    float h100 = hash3d(fl + zeroOne.yxx);
                    float h010 = hash3d(fl + zeroOne.xyx);
                    float h110 = hash3d(fl + zeroOne.yyx);
                    float h001 = hash3d(fl + zeroOne.xxy);
                    float h101 = hash3d(fl + zeroOne.yxy);
                    float h011 = hash3d(fl + zeroOne.xyy);
                    float h111 = hash3d(fl + zeroOne.yyy);
                    
                    return mixP(
                        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),
                        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y),
                        fr.z
                    );
                }
                
                float density(vec3 p) {
                    float final = noise(p * 0.03);
                    float other = noise(p * 0.03 + 1234.567);
                    other -= 0.5;
                    final -= 0.5;
                    final = 0.1 / (abs(final * final * other));
                    final += 0.5;
                    return final * 0.0001 * densityStrength;
                }
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy * 2.0 - 1.0;
                    uv.x *= resolution.x / resolution.y;
                    
                    // 相机设置
                    vec3 camUp = vec3(0, 1, 0);
                    vec3 camLookat = vec3(0, 0, 0);
                    
                    float mx = mouse.x * 3.14159265 * 2.0 + time * 0.01;
                    float my = -mouse.y * 10.0 + sin(time * 0.03) * 0.2 + 0.2;
                    vec3 camPos = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * 200.2;
                    
                    vec3 camVec = normalize(camLookat - camPos);
                    vec3 sideNorm = normalize(cross(camUp, camVec));
                    vec3 upNorm = cross(camVec, sideNorm);
                    vec3 worldFacing = camPos + camVec;
                    vec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;
                    vec3 relVec = normalize(worldPix - camPos);
                    
                    // 光线步进
                    float t = 0.0;
                    float inc = 0.02;
                    float densityAccum = 0.0;
                    
                    for (int i = 0; i < 37; i++) {
                        if (t > maxDepth) break;
                        vec3 pos = camPos + relVec * t;
                        float temp = density(pos);
                        
                        inc = stepLength + temp * 0.05;
                        densityAccum += temp * inc;
                        t += inc;
                    }
                    
                    // 颜色计算
                    vec3 finalColor = color * densityAccum * 0.2;
                    
                    // 应用伽马校正
                    gl_FragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)), 1.0);
                }
            `;

            // 编译着色器
            const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

            // 创建程序
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('无法链接着色器程序:', gl.getProgramInfoLog(program));
                return;
            }

            // 设置顶点缓冲区
            const vertices = new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        // 编译着色器
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // 设置事件监听
        function setupEventListeners() {
            // 鼠标事件
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;

                    rotationX += deltaX * 0.005;
                    rotationY += deltaY * 0.005;

                    // 限制Y轴旋转范围
                    rotationY = Math.max(-1.5, Math.min(1.5, rotationY));

                    lastX = e.clientX;
                    lastY = e.clientY;

                    // 更新鼠标位置
                    mouseX = rotationX;
                    mouseY = rotationY;
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // 触摸事件
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                }
            });

            window.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;

                    rotationX += deltaX * 0.005;
                    rotationY += deltaY * 0.005;

                    rotationY = Math.max(-1.5, Math.min(1.5, rotationY));

                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;

                    mouseX = rotationX;
                    mouseY = rotationY;
                }
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });

            // 滑块控制
            document.getElementById('densitySlider').addEventListener('input', (e) => {
                renderParams.densityStrength = parseFloat(e.target.value);
            });

            document.getElementById('stepSlider').addEventListener('input', (e) => {
                renderParams.stepLength = parseFloat(e.target.value);
            });

            document.getElementById('depthSlider').addEventListener('input', (e) => {
                renderParams.maxDepth = parseFloat(e.target.value);
            });

            // 色彩方案按钮
            document.querySelectorAll('.colorSchemeBtn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const colors = JSON.parse(btn.dataset.colors);
                    renderParams.color = colors;
                    renderParams.colorScheme = btn.querySelector('span').textContent;

                    // 更新显示
                    document.getElementById('colorScheme').textContent = renderParams.colorScheme;

                    // 高亮选中的按钮
                    document.querySelectorAll('.colorSchemeBtn').forEach(b => {
                        b.classList.remove('ring-2', 'ring-white');
                    });
                    btn.classList.add('ring-2', 'ring-white');
                });
            });

            // 色彩模式按钮
            document.getElementById('colorModeBtn').addEventListener('click', () => {
                const schemes = [
                    { colors: [0.01, 0.1, 1.0], name: "蓝色系" },
                    { colors: [1.0, 0.1, 0.3], name: "粉色系" },
                    { colors: [0.1, 1.0, 0.5], name: "绿色系" },
                    { colors: [1.0, 0.8, 0.1], name: "黄色系" },
                    { colors: [0.8, 0.1, 1.0], name: "紫色系" },
                    { colors: [0.8, 0.8, 0.8], name: "黑白系" }
                ];

                const currentIndex = schemes.findIndex(s => s.name === renderParams.colorScheme);
                const nextIndex = (currentIndex + 1) % schemes.length;
                const nextScheme = schemes[nextIndex];

                renderParams.color = nextScheme.colors;
                renderParams.colorScheme = nextScheme.name;

                // 更新显示
                document.getElementById('colorScheme').textContent = renderParams.colorScheme;

                // 高亮对应的按钮
                document.querySelectorAll('.colorSchemeBtn').forEach(btn => {
                    btn.classList.remove('ring-2', 'ring-white');
                    if (btn.querySelector('span').textContent === nextScheme.name) {
                        btn.classList.add('ring-2', 'ring-white');
                    }
                });
            });

            // 重置按钮
            document.getElementById('resetBtn').addEventListener('click', () => {
                renderParams.densityStrength = 1.0;
                renderParams.stepLength = 1.9;
                renderParams.maxDepth = 70.0;
                renderParams.color = [0.01, 0.1, 1.0];
                renderParams.colorScheme = "蓝色系";

                rotationX = 0;
                rotationY = 0;
                mouseX = 0;
                mouseY = 0;

                // 更新滑块
                document.getElementById('densitySlider').value = 1.0;
                document.getElementById('stepSlider').value = 1.9;
                document.getElementById('depthSlider').value = 70;

                // 更新显示
                document.getElementById('colorScheme').textContent = "蓝色系";

                // 高亮蓝色系按钮
                document.querySelectorAll('.colorSchemeBtn').forEach(btn => {
                    btn.classList.remove('ring-2', 'ring-white');
                    if (btn.querySelector('span').textContent === "蓝色系") {
                        btn.classList.add('ring-2', 'ring-white');
                    }
                });
            });
        }

        // 渲染函数
        function render(currentTime) {
            time = currentTime * 0.001;

            // 更新FPS计数器
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fpsCounter').textContent = `${fps} FPS`;
            }

            // 清除画布
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // 使用着色器程序
            gl.useProgram(program);

            // 设置uniform变量
            gl.uniform2f(gl.getUniformLocation(program, 'resolution'), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, 'time'), time);
            gl.uniform2f(gl.getUniformLocation(program, 'mouse'), mouseX, mouseY);
            gl.uniform1f(gl.getUniformLocation(program, 'densityStrength'), renderParams.densityStrength);
            gl.uniform1f(gl.getUniformLocation(program, 'stepLength'), renderParams.stepLength);
            gl.uniform1f(gl.getUniformLocation(program, 'maxDepth'), renderParams.maxDepth);
            gl.uniform3fv(gl.getUniformLocation(program, 'color'), renderParams.color);

            // 绘制
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 继续渲染
            requestAnimationFrame(render);
        }

        // 页面加载完成后初始化
        window.addEventListener('load', initWebGL);
    </script>
</body>

</html>